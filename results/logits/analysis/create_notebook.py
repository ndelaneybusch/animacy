import json
import os

notebook = {
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# Logit Analysis Results\n",
                "\n",
                "Analysis of logit data to understand the effect of system prompts on model responses.",
            ],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "import pandas as pd\n",
                "import numpy as np\n",
                "import matplotlib.pyplot as plt\n",
                "import seaborn as sns\n",
                "import ast\n",
                "\n",
                "# Set plot style\n",
                'sns.set_theme(style="whitegrid")\n',
                "plt.rcParams['figure.figsize'] = (12, 6)",
            ],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# File paths\n",
                "LOGPROBS_SYS_PATH = '../data/Qwen3-30B-A3B-Instruct-2507/logprobs_with_sys.csv'\n",
                "LOGPROBS_NO_SYS_PATH = '../data/Qwen3-30B-A3B-Instruct-2507/logprobs_no_sys.csv'\n",
                "RATINGS_PATH = '../../ratings/data/Qwen3-30B-A3B-Instruct-2507/response_ratings.csv'\n",
                "NORMS_PATH = '../../../data/selected_words.csv'\n",
                "\n",
                "# Load data\n",
                "df_sys = pd.read_csv(LOGPROBS_SYS_PATH)\n",
                "df_no_sys = pd.read_csv(LOGPROBS_NO_SYS_PATH)\n",
                "df_ratings = pd.read_csv(RATINGS_PATH)\n",
                "df_norms = pd.read_csv(NORMS_PATH)\n",
                "\n",
                'print("Loaded data shapes:")\n',
                'print(f"Sys: {df_sys.shape}")\n',
                'print(f"No Sys: {df_no_sys.shape}")\n',
                'print(f"Ratings: {df_ratings.shape}")\n',
                'print(f"Norms: {df_norms.shape}")',
            ],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Preprocessing\n",
                "\n",
                "# Rename no_sys columns\n",
                "df_no_sys = df_no_sys.rename(columns={\n",
                "    'average_log_probs': 'average_log_probs_no_sys',\n",
                "    'role_log_probs': 'role_log_probs_no_sys',\n",
                "    'role_period_log_prob': 'role_period_log_prob_no_sys',\n",
                "    'first_100_response_log_probs': 'first_100_response_log_probs_no_sys',\n",
                "    'first_100_response_text_len': 'first_100_response_text_len_no_sys'\n",
                "})\n",
                "\n",
                "# Merge logprobs\n",
                "df_merged = pd.merge(df_sys, df_no_sys, on=['role_name', 'task_name', 'sample_idx'], how='inner')\n",
                "\n",
                "# Merge with ratings\n",
                "df_merged = pd.merge(df_merged, df_ratings, on=['role_name', 'task_name', 'sample_idx'], how='left')\n",
                "\n",
                "# Merge with norms\n",
                "df_norms['Word_lower'] = df_norms['word'].str.lower().str.strip()\n",
                "df_merged['role_name_lower'] = df_merged['role_name'].str.lower().str.strip()\n",
                "\n",
                "df_full = pd.merge(df_merged, df_norms, left_on='role_name_lower', right_on='Word_lower', how='left')\n",
                "\n",
                "# Parse logprobs lists\n",
                "def parse_list(x):\n",
                "    if isinstance(x, str):\n",
                "        try:\n",
                "            return ast.literal_eval(x)\n",
                "        except:\n",
                "            return []\n",
                "    return x\n",
                "\n",
                "df_full['first_100_response_log_probs'] = df_full['first_100_response_log_probs'].apply(parse_list)\n",
                "df_full['first_100_response_log_probs_no_sys'] = df_full['first_100_response_log_probs_no_sys'].apply(parse_list)\n",
                "\n",
                'print(f"Merged dataframe shape: {df_full.shape}")',
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": ["## 1) Role Deviations Analysis"],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "deviation_cols = ['assistant_refusal', 'role_refusal', 'identify_as_assistant', 'deny_internal_experience']\n",
                "\n",
                "# Ensure boolean\n",
                "for col in deviation_cols:\n",
                "    df_full[col] = df_full[col].astype(bool)\n",
                "\n",
                "df_full['has_deviation'] = df_full[deviation_cols].any(axis=1)\n",
                "\n",
                'print("Deviation counts:")\n',
                "print(df_full[deviation_cols].sum())\n",
                "\n",
                "# Helper to get avg of first k tokens\n",
                "def get_avg_first_k(logprobs_list, k):\n",
                "    if not isinstance(logprobs_list, list) or len(logprobs_list) == 0:\n",
                "        return np.nan\n",
                "    return np.mean(logprobs_list[:k])\n",
                "\n",
                "# Calculate avg first k logprobs\n",
                "for k in [5, 10, 25]:\n",
                "    df_full[f'avg_first_{k}_sys'] = df_full['first_100_response_log_probs'].apply(lambda x: get_avg_first_k(x, k))\n",
                "    df_full[f'avg_first_{k}_no_sys'] = df_full['first_100_response_log_probs_no_sys'].apply(lambda x: get_avg_first_k(x, k))\n",
                "\n",
                "# Avg logits for deviations\n",
                "deviation_stats = []\n",
                "for col in deviation_cols:\n",
                "    deviated = df_full[df_full[col]]\n",
                "    if not deviated.empty:\n",
                "        stats = {'Deviation Type': col, 'Count': len(deviated)}\n",
                "        # Overall avg\n",
                "        stats['Avg (Sys)'] = deviated['average_log_probs'].mean()\n",
                "        stats['Avg (No Sys)'] = deviated['average_log_probs_no_sys'].mean()\n",
                "        # First k avg\n",
                "        for k in [5, 10, 25]:\n",
                "            stats[f'Avg First {k} (Sys)'] = deviated[f'avg_first_{k}_sys'].mean()\n",
                "            stats[f'Avg First {k} (No Sys)'] = deviated[f'avg_first_{k}_no_sys'].mean()\n",
                "        deviation_stats.append(stats)\n",
                "\n",
                "dev_df = pd.DataFrame(deviation_stats)\n",
                'print("\\nDeviation Statistics:")\n',
                "print(dev_df)\n",
                "\n",
                "# Create box+scatter plots for each k\n",
                "for k in [5, 10, 25]:\n",
                "    # Prepare data for plotting\n",
                "    plot_data = []\n",
                "    for col in deviation_cols:\n",
                "        deviated = df_full[df_full[col]]\n",
                "        if not deviated.empty:\n",
                "            # Add sys data\n",
                "            for val in deviated[f'avg_first_{k}_sys']:\n",
                "                if not pd.isna(val):\n",
                "                    plot_data.append({'Deviation Type': col, 'Log Prob': val, 'Condition': 'With Sys'})\n",
                "            # Add no-sys data\n",
                "            for val in deviated[f'avg_first_{k}_no_sys']:\n",
                "                if not pd.isna(val):\n",
                "                    plot_data.append({'Deviation Type': col, 'Log Prob': val, 'Condition': 'No Sys'})\n",
                "    \n",
                "    plot_df = pd.DataFrame(plot_data)\n",
                "    \n",
                "    if not plot_df.empty:\n",
                "        plt.figure(figsize=(12, 6))\n",
                "        sns.boxplot(data=plot_df, x='Deviation Type', y='Log Prob', hue='Condition', palette='Set2')\n",
                "        sns.stripplot(data=plot_df, x='Deviation Type', y='Log Prob', hue='Condition', dodge=True, alpha=0.3, size=3, legend=False)\n",
                "        plt.title(f'Log Probability Distribution for Deviations (First {k} Tokens)')\n",
                "        plt.xticks(rotation=15, ha='right')\n",
                "        plt.tight_layout()\n",
                "        plt.show()",
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": ["## 1b) Distinguishing Role-Specific vs Generic Deviations"],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "df_deviations = df_full[df_full['has_deviation']].copy()\n",
                "df_deviations['logit_diff'] = df_deviations['average_log_probs'] - df_deviations['average_log_probs_no_sys']\n",
                "\n",
                "# Scatter plot\n",
                "plt.figure(figsize=(10, 6))\n",
                "sns.scatterplot(data=df_deviations, x='average_log_probs_no_sys', y='average_log_probs', hue='task_name', style='group', alpha=0.7)\n",
                "plt.plot([-2, 0], [-2, 0], 'r--', label='Identity (No Effect)')\n",
                "plt.title('Logits of Deviated Responses: With vs Without System Prompt')\n",
                "plt.xlabel('Average Log Probs (No System Prompt)')\n",
                "plt.ylabel('Average Log Probs (With System Prompt)')\n",
                "plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n",
                "plt.show()\n",
                "\n",
                "# Analyze by Role\n",
                'print("\\n--- Top Roles by Logit Diff (Role-Specific Deviations) ---")\n',
                "role_diff = df_deviations.groupby('role_name')['logit_diff'].agg(['mean', 'count']).sort_values('mean', ascending=False)\n",
                "print(role_diff.head(20))\n",
                "print(role_diff.tail(20))\n",
                "\n",
                "# Analyze by Group\n",
                'print("\\n--- Logit Diff by Group ---")\n',
                "if 'group' in df_deviations.columns:\n",
                "    print(df_deviations.groupby('group')['logit_diff'].agg(['mean', 'count']).sort_values('mean', ascending=False))\n",
                "\n",
                'print("\\n--- Logit Diff by Category ---")\n',
                "if 'broad_category' in df_deviations.columns:\n",
                "    print(df_deviations.groupby('broad_category')['logit_diff'].agg(['mean', 'count']).sort_values('mean', ascending=False))\n",
                "\n",
                "# Boxplots for deny_internal_experience only\n",
                "df_deny = df_full[df_full['deny_internal_experience']].copy()\n",
                "df_deny['logit_diff'] = df_deny['average_log_probs'] - df_deny['average_log_probs_no_sys']\n",
                "\n",
                "if not df_deny.empty:\n",
                "    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n",
                "    \n",
                "    if 'group' in df_deny.columns:\n",
                "        sns.boxplot(data=df_deny, x='group', y='logit_diff', ax=ax1, palette='Set2')\n",
                "        sns.stripplot(data=df_deny, x='group', y='logit_diff', ax=ax1, color='black', alpha=0.3, size=3)\n",
                "        ax1.set_title('Logit Diff by Group (deny_internal_experience only)')\n",
                "        ax1.set_xticklabels(ax1.get_xticklabels(), rotation=15, ha='right')\n",
                "        ax1.axhline(0, color='red', linestyle='--', alpha=0.5)\n",
                "    \n",
                "    if 'broad_category' in df_deny.columns:\n",
                "        sns.boxplot(data=df_deny, x='broad_category', y='logit_diff', ax=ax2, palette='Set3')\n",
                "        sns.stripplot(data=df_deny, x='broad_category', y='logit_diff', ax=ax2, color='black', alpha=0.3, size=3)\n",
                "        ax2.set_title('Logit Diff by Category (deny_internal_experience only)')\n",
                "        ax2.set_xticklabels(ax2.get_xticklabels(), rotation=15, ha='right')\n",
                "        ax2.axhline(0, color='red', linestyle='--', alpha=0.5)\n",
                "    \n",
                "    plt.tight_layout()\n",
                "    plt.show()\n",
                "\n",
                "# Create Assistant-like group and plot\n",
                "assistant_like_roles = ['lawyer', 'engineer', 'referee', 'professor', 'physician', 'scientist']\n",
                "df_deny['group_modified'] = df_deny.apply(\n",
                "    lambda row: 'Assistant-like' if isinstance(row['role_name'], str) and row['role_name'].lower() in assistant_like_roles else row.get('group', 'Other'),\n",
                "    axis=1\n",
                ")\n",
                "\n",
                "if not df_deny.empty:\n",
                "    plt.figure(figsize=(10, 6))\n",
                "    sns.boxplot(data=df_deny, x='group_modified', y='logit_diff', palette='Set2')\n",
                "    sns.stripplot(data=df_deny, x='group_modified', y='logit_diff', color='black', alpha=0.3, size=3)\n",
                "    plt.title('Logit Diff by Group (with Assistant-like) - deny_internal_experience only')\n",
                "    plt.xlabel('Group')\n",
                "    plt.ylabel('Logit Diff')\n",
                "    plt.xticks(rotation=15, ha='right')\n",
                "    plt.axhline(0, color='red', linestyle='--', alpha=0.5)\n",
                "    plt.tight_layout()\n",
                "    plt.show()",
            ],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Filter out deviations for remainder of analysis\n",
                "df_clean = df_full[~df_full['has_deviation']].copy()\n",
                'print(f"\\nClean dataframe shape (Deviations removed): {df_clean.shape}")',
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1c) Role Logprobs vs Response Start (First 5 Tokens)\n",
                "\n",
                "Comparing the likelihood of the assigned role (in the system prompt) to the likelihood of the start of the model's response.",
            ],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "def get_avg_first_k(logprobs_list, k=5):\n",
                "    if not isinstance(logprobs_list, list) or len(logprobs_list) == 0:\n",
                "        return np.nan\n",
                "    return np.mean(logprobs_list[:k])\n\nif df_clean['role_log_probs'].notna().any():\n    df_clean['avg_first_5_logprobs'] = df_clean['first_100_response_log_probs'].apply(lambda x: get_avg_first_k(x, 5))\n\n    plt.figure(figsize=(10, 6))\n    sns.scatterplot(data=df_clean, x='role_log_probs', y='avg_first_5_logprobs', hue='task_name', style='group', alpha=0.7)\n    plt.title('Role Logprobs vs Average First 5 Response Logprobs')\n    plt.xlabel('Role Log Probability (Likelihood of Role Name)')\n    plt.ylabel('Avg Log Probability of First 5 Response Tokens')\n    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n    plt.show()\n\n    # Correlation per task\n    print(\"Correlation between Role Logprobs and Response Start (per task):\")\n    print(df_clean.groupby('task_name')[['role_log_probs', 'avg_first_5_logprobs']].corr().iloc[0::2, -1])\nelse:\n    print(\"No role_log_probs data available. Skipping Section 1c analysis.\")",
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": ["## 2) First 100 Token Logprobs Plot"],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "def get_avg_trajectory(series_of_lists):\n",
                "    # Find max length\n",
                "    max_len = series_of_lists.apply(len).max()\n",
                "    if pd.isna(max_len) or max_len == 0:\n",
                "        return np.array([])\n",
                "    \n",
                "    # Create a matrix\n",
                "    matrix = np.full((len(series_of_lists), 100), np.nan)\n",
                "    for i, lst in enumerate(series_of_lists):\n",
                "        if len(lst) > 0:\n",
                "            length = min(len(lst), 100)\n",
                "            matrix[i, :length] = lst[:length]\n",
                "            \n",
                "    return np.nanmean(matrix, axis=0)\n",
                "\n",
                "avg_traj_sys = get_avg_trajectory(df_clean['first_100_response_log_probs'])\n",
                "avg_traj_no_sys = get_avg_trajectory(df_clean['first_100_response_log_probs_no_sys'])\n",
                "\n",
                "plt.figure(figsize=(10, 6))\n",
                "plt.plot(avg_traj_sys, label='With System Prompt')\n",
                "plt.plot(avg_traj_no_sys, label='No System Prompt')\n",
                "plt.xlabel('Token Position')\n",
                "plt.ylabel('Average Log Probability')\n",
                "plt.ylim(-15, 0)\n",
                "plt.title('Average Log Probability Trajectory (First 100 Tokens)')\n",
                "plt.legend()\n",
                "plt.show()",
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3) Per-Task Convergence and Residual Gap (Avg 40-50 & 90-100)"
            ],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "def get_avg_residual_gap_range(traj_sys, traj_no_sys, start, end):\n",
                "    # Ensure bounds\n",
                "    if start >= len(traj_sys):\n",
                "        return np.nan\n",
                "    \n",
                "    actual_end = min(end, len(traj_sys))\n",
                "    if start >= actual_end:\n",
                "        return np.nan\n",
                "        \n",
                "    diff = np.abs(traj_sys[start:actual_end] - traj_no_sys[start:actual_end])\n",
                "    return np.nanmean(diff)\n",
                "\n",
                "tasks = df_clean['task_name'].unique()\n",
                "task_convergence = {}\n",
                "task_residual_gap_40_50 = {}\n",
                "task_residual_gap_90_100 = {}\n",
                "\n",
                "fig, axes = plt.subplots(len(tasks), 1, figsize=(10, 4*len(tasks)), sharex=True)\n",
                "if len(tasks) == 1: axes = [axes]\n",
                "\n",
                "for i, task in enumerate(tasks):\n",
                "    task_df = df_clean[df_clean['task_name'] == task]\n",
                "    \n",
                "    traj_sys = get_avg_trajectory(task_df['first_100_response_log_probs'])\n",
                "    traj_no_sys = get_avg_trajectory(task_df['first_100_response_log_probs_no_sys'])\n",
                "    \n",
                "    ax = axes[i]\n",
                "    ax.plot(traj_sys, label='With Sys')\n",
                "    ax.plot(traj_no_sys, label='No Sys')\n",
                "    ax.set_title(f'Task: {task}')\n",
                "    ax.set_ylim(-15, 0)\n",
                "    ax.legend()\n",
                "    \n",
                "    # Estimate convergence: first index where diff < 0.5 for 5 consecutive tokens\n",
                "    diff = np.abs(traj_sys - traj_no_sys)\n",
                "    conv_idx = np.nan\n",
                "    for idx in range(len(diff) - 5):\n",
                "        if np.all(diff[idx:idx+5] < 0.5):\n",
                "            conv_idx = idx\n",
                "            break\n",
                "    \n",
                "    task_convergence[task] = conv_idx\n",
                "    task_residual_gap_40_50[task] = get_avg_residual_gap_range(traj_sys, traj_no_sys, 40, 50)\n",
                "    task_residual_gap_90_100[task] = get_avg_residual_gap_range(traj_sys, traj_no_sys, 90, 100)\n",
                "    \n",
                "    if not np.isnan(conv_idx):\n",
                "        ax.axvline(conv_idx, color='r', linestyle='--', label=f'Conv: {conv_idx}')\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()\n",
                "\n",
                'print("Estimated Convergence Points per Task:")\n',
                "print(task_convergence)\n",
                'print("\\nAvg Residual Gap 40-50 per Task:")\n',
                "print(task_residual_gap_40_50)\n",
                'print("\\nAvg Residual Gap 90-100 per Task:")\n',
                "print(task_residual_gap_90_100)\n",
                "\n",
                "# Boxplots for residual gaps by task\n",
                "gap_data = []\n",
                "for task, gap in task_residual_gap_40_50.items():\n",
                "    if not np.isnan(gap):\n",
                "        gap_data.append({'Task': task, 'Residual Gap': gap, 'Range': '40-50'})\n",
                "for task, gap in task_residual_gap_90_100.items():\n",
                "    if not np.isnan(gap):\n",
                "        gap_data.append({'Task': task, 'Residual Gap': gap, 'Range': '90-100'})\n",
                "\n",
                "if gap_data:\n",
                "    gap_df = pd.DataFrame(gap_data)\n",
                "    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n",
                "    \n",
                "    # 40-50 range\n",
                "    gap_40_50 = gap_df[gap_df['Range'] == '40-50']\n",
                "    if not gap_40_50.empty:\n",
                "        sns.boxplot(data=gap_40_50, x='Task', y='Residual Gap', ax=ax1, palette='Set2')\n",
                "        sns.stripplot(data=gap_40_50, x='Task', y='Residual Gap', ax=ax1, color='black', alpha=0.5, size=4)\n",
                "        ax1.set_title('Avg Residual Gap 40-50 by Task')\n",
                "        ax1.set_xticklabels(ax1.get_xticklabels(), rotation=15, ha='right')\n",
                "    \n",
                "    # 90-100 range\n",
                "    gap_90_100 = gap_df[gap_df['Range'] == '90-100']\n",
                "    if not gap_90_100.empty:\n",
                "        sns.boxplot(data=gap_90_100, x='Task', y='Residual Gap', ax=ax2, palette='Set3')\n",
                "        sns.stripplot(data=gap_90_100, x='Task', y='Residual Gap', ax=ax2, color='black', alpha=0.5, size=4)\n",
                "        ax2.set_title('Avg Residual Gap 90-100 by Task')\n",
                "        ax2.set_xticklabels(ax2.get_xticklabels(), rotation=15, ha='right')\n",
                "    \n",
                "    plt.tight_layout()\n",
                "    plt.show()",
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": ["## 4) Role Convergence and Residual Gap vs Norms"],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "roles = df_clean['role_name'].unique()\n",
                "role_convergence = {}\n",
                "role_residual_gap_40_50 = {}\n",
                "role_residual_gap_90_100 = {}\n",
                "\n",
                "for role in roles:\n",
                "    role_df = df_clean[df_clean['role_name'] == role]\n",
                "    traj_sys = get_avg_trajectory(role_df['first_100_response_log_probs'])\n",
                "    traj_no_sys = get_avg_trajectory(role_df['first_100_response_log_probs_no_sys'])\n",
                "    \n",
                "    diff = np.abs(traj_sys - traj_no_sys)\n",
                "    conv_idx = np.nan\n",
                "    for idx in range(len(diff) - 5):\n",
                "        if np.all(diff[idx:idx+5] < 0.5):\n",
                "            conv_idx = idx\n",
                "            break\n",
                "    role_convergence[role] = conv_idx\n",
                "    role_residual_gap_40_50[role] = get_avg_residual_gap_range(traj_sys, traj_no_sys, 40, 50)\n",
                "    role_residual_gap_90_100[role] = get_avg_residual_gap_range(traj_sys, traj_no_sys, 90, 100)\n",
                "\n",
                "role_conv_df = pd.DataFrame({\n",
                "    'role_name': list(role_convergence.keys()),\n",
                "    'convergence_point': list(role_convergence.values()),\n",
                "    'residual_gap_40_50': list(role_residual_gap_40_50.values()),\n",
                "    'residual_gap_90_100': list(role_residual_gap_90_100.values())\n",
                "})\n",
                "\n",
                "# Merge with norms\n",
                "role_conv_full = pd.merge(role_conv_df, df_norms, left_on=role_conv_df['role_name'].str.lower(), right_on='Word_lower', how='left')\n",
                "\n",
                "# Map new column names to properties\n",
                "property_map = {\n",
                "    'Living': 'Living',\n",
                "    'Thought': 'thought_mean',\n",
                "    'Repro': 'repro_mean',\n",
                "    'Person': 'person_mean',\n",
                "    'Goals': 'goals_mean',\n",
                "    'Move': 'move_mean',\n",
                "    'AnimMental': 'anim_mental',\n",
                "    'AnimPhysical': 'anim_physical',\n",
                "    'AoA': 'age_of_acquisition',\n",
                "    'VAL': 'valence',\n",
                "    'IMG': 'IMG',\n",
                "    'CNC': 'concreteness'\n",
                "}\n",
                "\n",
                "for label, col in property_map.items():\n",
                "    if col in role_conv_full.columns:\n",
                "        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 5))\n",
                "        \n",
                "        sns.scatterplot(data=role_conv_full, x=col, y='convergence_point', hue='group', ax=ax1, legend=False)\n",
                "        ax1.set_title(f'Convergence Point vs {label}')\n",
                "        \n",
                "        sns.scatterplot(data=role_conv_full, x=col, y='residual_gap_40_50', hue='group', ax=ax2, legend=False)\n",
                "        ax2.set_title(f'Avg Residual Gap 40-50 vs {label}')\n",
                "        \n",
                "        sns.scatterplot(data=role_conv_full, x=col, y='residual_gap_90_100', hue='group', ax=ax3, legend=False)\n",
                "        ax3.set_title(f'Avg Residual Gap 90-100 vs {label}')\n",
                "        \n",
                "        # 3. Create a single Figure-level legend\n"
                "        # We grab the handles/labels from one of the axes to generate the legend\n"
                "        handles, labels = ax3.get_legend_handles_labels()\n"
                "        fig.legend(handles, labels, loc='lower center', ncol=4, bbox_to_anchor=(0.5, -0.05))\n"
                "        \n",
                "        plt.tight_layout()\n",
                "        plt.subplots_adjust(bottom=0.2)\n",
                "        plt.show()",
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": ["## 4b) Role Convergence with Assistant-like Grouping"],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create Assistant-like group for df_clean\n",
                "assistant_like_roles = ['lawyer', 'engineer', 'referee', 'professor', 'physician', 'scientist']\n",
                "df_clean['group_modified'] = df_clean.apply(\n",
                "    lambda row: 'Assistant-like' if isinstance(row['role_name'], str) and row['role_name'].lower() in assistant_like_roles else row.get('group', 'Other'),\n",
                "    axis=1\n",
                ")\n",
                "\n",
                "# Calculate logit diff for df_clean\n",
                "df_clean['logit_diff'] = df_clean['average_log_probs'] - df_clean['average_log_probs_no_sys']\n",
                "\n",
                "if not df_clean.empty:\n",
                "    plt.figure(figsize=(10, 6))\n",
                "    sns.boxplot(data=df_clean, x='group_modified', y='logit_diff', palette='Set2')\n",
                "    sns.stripplot(data=df_clean, x='group_modified', y='logit_diff', color='black', alpha=0.3, size=3)\n",
                "    plt.title('Logit Diff by Group (with Assistant-like) - Clean Data')\n",
                "    plt.xlabel('Group')\n",
                "    plt.ylabel('Logit Diff')\n",
                "    plt.xticks(rotation=15, ha='right')\n",
                "    plt.axhline(0, color='red', linestyle='--', alpha=0.5)\n",
                "    plt.tight_layout()\n",
                "    plt.show()",
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": ["## 5) Convergence and Residual Gap vs No-Sys Avg Logits"],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "def get_convergence_and_gaps_single(row):\n",
                "    l1 = row['first_100_response_log_probs']\n",
                "    l2 = row['first_100_response_log_probs_no_sys']\n",
                "    if not isinstance(l1, list) or not isinstance(l2, list): return np.nan, np.nan, np.nan\n",
                "    \n",
                "    min_len = min(len(l1), len(l2))\n",
                "    if min_len < 10: return np.nan, np.nan, np.nan\n",
                "    \n",
                "    arr1 = np.array(l1[:min_len])\n",
                "    arr2 = np.array(l2[:min_len])\n",
                "    \n",
                "    diff = np.abs(arr1 - arr2)\n",
                "    conv_idx = np.nan\n",
                "    for idx in range(len(diff) - 5):\n",
                "        if np.all(diff[idx:idx+5] < 0.5):\n",
                "            conv_idx = idx\n",
                "            break\n",
                "    \n",
                "    gap_40_50 = np.nanmean(diff[40:50]) if min_len > 40 else np.nan\n",
                "    gap_90_100 = np.nanmean(diff[90:100]) if min_len > 90 else np.nan\n",
                "        \n",
                "    return conv_idx, gap_40_50, gap_90_100\n",
                "\n",
                "results = df_clean.apply(get_convergence_and_gaps_single, axis=1, result_type='expand')\n",
                "df_clean['convergence_point'] = results[0]\n",
                "df_clean['residual_gap_40_50'] = results[1]\n",
                "df_clean['residual_gap_90_100'] = results[2]\n",
                "\n",
                "fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 6))\n",
                "\n",
                "sns.scatterplot(data=df_clean, x='average_log_probs_no_sys', y='convergence_point', hue='group', ax=ax1)\n",
                "ax1.set_title('Convergence Point vs No-Sys Avg Logits')\n",
                "\n",
                "sns.scatterplot(data=df_clean, x='average_log_probs_no_sys', y='residual_gap_40_50', hue='group', ax=ax2)\n",
                "ax2.set_title('Avg Residual Gap 40-50 vs No-Sys Avg Logits')\n",
                "\n",
                "sns.scatterplot(data=df_clean, x='average_log_probs_no_sys', y='residual_gap_90_100', hue='group', ax=ax3)\n",
                "ax3.set_title('Avg Residual Gap 90-100 vs No-Sys Avg Logits')\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()",
            ],
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": ["## 6) Logit Change vs Role Properties"],
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "df_clean['logit_diff'] = df_clean['average_log_probs'] - df_clean['average_log_probs_no_sys']\n",
                "\n",
                "for label, col in property_map.items():\n",
                "    if col in df_clean.columns:\n",
                "        plt.figure(figsize=(6, 4))\n",
                "        sns.scatterplot(data=df_clean, x=col, y='logit_diff', hue='group')\n",
                "        plt.title(f'Logit Diff vs {label}')\n",
                "        plt.show()",
            ],
        },
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3",
        },
        "language_info": {
            "codemirror_mode": {"name": "ipython", "version": 3},
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.8.5",
        },
    },
    "nbformat": 4,
    "nbformat_minor": 4,
}

with open("results/logits/analysis/logits_results.ipynb", "w") as f:
    json.dump(notebook, f, indent=1)
